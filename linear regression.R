library(ggplot2)
library(dplyr)
library(psych)
library(tidyr)
df1 <- read.csv("x_data_widsegments.csv")
colnames(df1)
summary(aov(df1$basketsizes~df1$product_group_name))
summary(aov(df1$basketsizes~df1$garment_group_name))
summary(aov(df1$basketsizes~df1$graphical_appearance_name))
summary(aov(df1$basketsizes~df1$perceived_colour_master_name))
df1$kmeanscluster <- as.factor(df1$kmeanscluster)
model1 <- lm(basketsizes ~ age + garment_group_name + graphical_appearance_name +
               memberships_and_FN +
               age +  section_name,
            data = df1)
summary(model1)
df1$prediction1 <- predict(model1)
ggplot(df1, aes(x = prediction1, y = basketsizes)) + geom_point() + 
  geom_abline(colour = 'darkblue') + ggtitle("pred vs actuals")
##**
set.seed(123)
trainind <- sample(1:nrow(df1),size = floor(0.70*nrow(df1)))
traindf1 <- df1[trainind,]
testdf1 <- df1[-trainind,]
model2 <- lm(basketsizes ~ kmeanscluster + log(age) + garment_group_name + 
               graphical_appearance_name + memberships_and_FN,
             data = traindf1)
summary(model2)
model_coeff1 <- data.frame(summary(model2)$coefficients)
step(model2, direction = "both" )
write.csv(model_coeff1, "model_coeff.csv")
df1$prediction <- predict(model2)
ggplot(df1, aes(x = prediction, y = basketsizes)) + geom_point() + 
  geom_abline(colour = 'darkblue') + ggtitle("pred vs actuals")
traindf1a <- cbind(traindf1, predbasketsize = predict(model2, newdata = traindf1))
declocations <- quantile(traindf1a$predbasketsize, probs = seq(0.1, 0.9, by = 0.1 ))
##categorising the predtotalspent into decile ranks using the declocation 
traindf1a$decilerank <- findInterval(traindf1a$basketsize,c(-Inf, declocations, Inf))
View(traindf1a)


##We also calculate the mape, corr and min_max_accuracy by implementitng the model on train dataset
actuals_preds <- data.frame(cbind(actuals=traindf1a$basketsizes, predicted= traindf1a$predbasketsize))  
correlation_accuracy <- cor(actuals_preds)  
head(actuals_preds)

min_max_accuracy <- mean(apply(actuals_preds, 1, min) / apply(actuals_preds, 1, max))  
mape <- mean(abs((actuals_preds$predicted - actuals_preds$actuals))/actuals_preds$actuals)
mape
min_max_accuracy
correlation_accuracy




##Next we validate the model on the test dataset
testdf1a <- cbind(testdf1, predbasketsizes = predict(model2, newdata = testdf1))
##Decile analysis for test dataset predicted values
declocations1 <- quantile(testdf1a$predbasketsizes, probs = seq(0.1, 0.9, by = 0.1 ))

##categorising the predtotalspent into decile ranks using the declocation 
testdf1a$decilerank <- findInterval(testdf1a$predbasketsizes,c(-Inf, declocations1, Inf))
View(testdf1a)

##We also calculate the mape, corr and min_max_accuracy by implementitng the model on test dataset
actuals_preds <- data.frame(cbind(actuals=testdf1a$basketsizes, predicted= testdf1a$predbasketsizes))  
correlation_accuracy <- cor(actuals_preds)  
head(actuals_preds)

min_max_accuracy <- mean(apply(actuals_preds, 1, min) / apply(actuals_preds, 1, max))  
mape <- mean(abs((actuals_preds$predicted - actuals_preds$actuals))/actuals_preds$actuals)
mape
min_max_accuracy
correlation_accuracy













































































































































































































































































































































































































































































































































































































































































































































































